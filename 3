![Time_Series_Header](https://raw.githubusercontent.com/satishgunjal/images/master/Time_Series_Header_1000x690.png)
# Оглавление

* [Что такое временной ряд](#1)
  - [Характеристики временного ряда](#2)
    + [Тренд](#3)
    + [Сезонность](#4)
    + [Иррегулярности](#5)
    + [Цикличность](#6)
* [Анализ временных рядов](#7)
  - [Разложение временного ряда](#8)
  - [Стационарные данные](#9)
  - [Тест на стационарность](#10)
    + [Статистика вращения](#11)
    + [Расширенный тест Дики-Фуллера](#12)
  - [Преобразование нестационарных данных в стационарные данные](#13)
    + [Дифференциция](#14)
    + [Трансформация](#15)
    + [Скользящее среднее](#16)
      + [Взвешенные скользящие средние (WMA)](#17)
      + [Центрированные скользящие средние (CMS)](#18)
      + [Скользящие движущиеся средние (TMA)](#19)
  - [Корреляция](#20)
    + [ACF: функция автокорреляции](#21)
    + [PACF: функция частичной автокорреляции](#22)
* [Прогнозирование временных рядов](#23)
  - [Модели, используемые для прогнозирования временных рядов](#24)
  - [ARIMA](#25)
    + [Авторегрессивная (AR) модель](#26)
    + [Интеграция(I)](#27)
    + [Модель скользящей средней (MA)](#28)
* [Пример Python](#29)
  - [Импорт библиотеки](#30)
  - [Понимание данных](#31)
  - [Характеристики временного ряда](#32)
  - [Анализ](#33)
  - [Прогнозирование](#34)
# Что такое временной ряд <a id ="1"></a>
Любые данные, записанные с некоторым фиксированным интервалом времени, называются данными временного ряда. Этот фиксированный интервал может быть часовым, дневным, месячным или годовым. Например почасовое показание температуры, ежедневно меняющиеся цены на топливо, ежемесячный счет за электроэнергию, аннулированный отчет о прибыли компании и т.д. В данных временных рядов время всегда является независимой переменной, и может быть одна или несколько зависимых переменных.

Временной ряд прогнозирования продаж с продажами шампуня за каждый месяц будет выглядеть следующим образом:

![Shampoo_Sales](https://raw.githubusercontent.com/satishgunjal/images/master/Shampoo_Sales.png)

В приведенном выше примере, поскольку существует только одна переменная, зависящая от времени, ряд называется одномерным временным рядом. Если есть несколько зависимых переменных, то этот ряд называется многомерным временным рядом.

Цель анализа временных рядов состоит в том, чтобы понять, как изменение во времени влияет на зависимые переменные, и, соответственно, спрогнозировать значения для будущих временных интервалов.


## Характеристики временных рядов <a id ="2"></a>
Среднее значение, стандартное отклонение и сезонность определяют различные характеристики временного ряда.

![Time_Series_Characteristics](https://raw.githubusercontent.com/satishgunjal/images/master/Time_Series_Characteristics.png)

Ниже приведены важные характеристики временного ряда.

### Тренд <a id ="3"></a>
Тенденция представляет собой изменение зависимых переменных во времени от начала до конца. В случае увеличения тренда зависимая переменная будет увеличиваться со временем и наоборот. Нет необходимости иметь определенную тенденцию во временном ряду, мы можем иметь один временной ряд с возрастающей и убывающей тенденцией. Короче говоря, тренд представляет собой различное среднее значение данных временного ряда.

![Trend](https://raw.githubusercontent.com/satishgunjal/images/master/Trend.png)

### Сезонность <a id ="4"></a>
Если наблюдения повторяются через фиксированный интервал времени, то они называются сезонными наблюдениями. Эти сезонные изменения в данных могут происходить из-за природных или антропогенных явлений. Например, каждый год продажи теплых вещей увеличиваются перед зимним сезоном. Таким образом, сезонность представляет собой вариации данных с фиксированными интервалами.

![Seasonality](https://raw.githubusercontent.com/satishgunjal/images/master/Seasonality.png)

### Иррегулярность <a id ="5"></a>
Эта характеристика также называется шумом. Странные провалы и скачки в данных называются иррегуляциями. Эти колебания вызваны неконтролируемыми событиями, такими как землетрясения, войны, наводнения, пандемии и т.д. Например, из-за пандемии COVID-19 существует огромный спрос на дезинфицирующие средства для рук и маски.

![Irregularities](https://raw.githubusercontent.com/satishgunjal/images/master/Irregularities.png)

### Цикличность <a id ="6"></a>
Цикличность возникает, когда наблюдения в рядах повторяются случайным образом. Обратите внимание, что если есть какая-то фиксированная закономерность, то она становится сезонностью, в случае цикличности наблюдения могут повторяться через неделю, месяцы или могут быть через год. Такие закономерности гораздо труднее предсказать.

![Cyclicity](https://raw.githubusercontent.com/satishgunjal/images/master/Cyclicity.png)

Данные временных рядов, которые имеют вышеуказанные характеристики, называются «нестационарными данными». Для любого анализа данных временных рядов мы должны преобразовать их в «Стационарные данные».

Общее правило состоит в том, чтобы оценить тенденцию и сезонность во временном ряду, а затем сделать временной ряд стационарным для моделирования данных. При моделировании данных пошаговые статистические методы используются для анализа и прогнозирования временных рядов. Когда у нас есть прогнозы, на последнем этапе прогнозируемые значения преобразуются в исходную шкалу путем обратного применения ограничений тренда и сезонности.


# Анализ временных рядов <a id ="7"></a>
Как следует из названия, этот процесс анализирует данные временных рядов для выявления в них закономерностей. Кратко приведем объяснение различных методов и тестов для анализа данных временных рядов.

## Декомпозиция временных рядов <a id ="8"></a>
Декомпозиция временного ряда помогает разбить временной ряд на несколько компонентов, таких как тренд и сезонность, для лучшей визуализации его характеристик. Использование декомпозиции временных рядов упрощает быстрое определение изменяющегося среднего значения или вариации данных.

![Decomposition_of_Time_Series](https://raw.githubusercontent.com/satishgunjal/images/master/Decomposition_of_Time_Series.png)

## Стационарные данные <a id ="9"></a>
Для точного анализа и прогнозирования тренд и сезонность удаляются из временного ряда и преобразуются в стационарный ряд.
Данные временных рядов называются стационарными, когда статистические свойства, такие как среднее значение, стандартное отклонение, постоянны и нет сезонности. Другими словами, статистические свойства данных временных рядов не должны зависеть от времени.

![Stationarity](https://raw.githubusercontent.com/satishgunjal/images/master/Stationarity.png)

## Тест на стационарность <a id ="10"></a>
Простой способ — посмотреть на график и найти любую очевидную тенденцию или сезонность. При работе с реальными данными мы также можем использовать более сложные методы, такие как скользящая статистика и расширенный тест Дики-Фуллера, для проверки стационарности данных.

### Скользящая статистика <a id ="11"></a>
В методе скользящей статистики мы определяем размер окна для расчета среднего значения и стандартного отклонения по всему ряду. Для стационарных рядов среднее значение и стандартное отклонение не должны меняться со временем.

### Расширенный тест Дики-Фуллера (ADF) <a id ="12"></a>
Не будем вдаваться в подробности того, как работает этот тест. Больше сосредоточимся на том, как интерпретировать результат этого теста для определения стационарности ряда. Тест ADF вернет выходные значения «p-value» (р-значение) и «Test Statistics» (Тестовая статистика).
* **р-значение > 0,05**: нестационарное.
* **р-значение <= 0,05**: стационарное.
* **Тестовая статистика**: чем больше отрицательное значение, тем вероятнее, что мы имеем стационарный ряд. Кроме того, это значение должно быть меньше критических значений (1%, 5%, 10%). Например, Если тестовая статистика меньше 5% критических значений, то мы можем с уверенностью в 95% сказать, что это стационарный ряд.

## Преобразование нестационарных данных в стационарные <a id ="13"></a>
Учет характеристик данных временных рядов, таких как тенденция и сезонность, называется обеспечением стационарности данных. Таким образом, сделав среднее значение и дисперсию временного ряда постоянными, мы получим стационарные данные. Ниже приведены несколько техник, используемых для этого…

### Дифференциация <a id ="14"></a>
Техника дифференцирования помогает удалить тренд и сезонность из данных временных рядов. Дифференцирование выполняется путем вычитания предыдущего наблюдения из текущего наблюдения. Дифференцированные данные будут содержать на одну точку данных меньше, чем исходные данные. Таким образом, разность фактически уменьшает количество наблюдений и стабилизирует среднее значение временного ряда.

```
разница = предыдущее наблюдение - текущее наблюдение
```
После выполнения дифференцирования рекомендуется построить график данных и визуализировать изменение. В случае недостаточного улучшения можно выполнить дифференцирование второго или даже третьего порядка.

### Преобразование <a id ="15"></a>
Простой, но часто эффективный способ стабилизировать дисперсию во времени — применить степенное преобразование к временному ряду. Логариф, квадратный корень, кубический корень - наиболее часто используемые методы преобразования.
В большинстве случаев вы можете выбрать тип роста временного ряда и соответственно выбрать метод преобразования. Например, временной ряд с квадратичной тенденцией роста можно сделать линейным, взяв квадратный корень. В случае, если дифференцирование не работает, вы можете сначала использовать один из вышеперечисленных методов преобразования, чтобы удалить вариацию из ряда.

![Log_Transformation](https://raw.githubusercontent.com/satishgunjal/images/master/Log_Transformation.png)

### Скользящее среднее (Moving Average)<a id ="16"></a>
В методе скользящих средних новый ряд создается путем взятия средних значений точек данных из исходного ряда. В этом методе мы можем использовать две или более точек необработанных данных для расчета среднего значения. Это также называется «шириной окна (w)». Как только ширина окна определена, средние значения рассчитываются от начала до конца для каждого набора w последовательных значений, отсюда и название скользящих средних. Его также можно использовать для прогнозирования временных рядов.

![Moving_Average](https://raw.githubusercontent.com/satishgunjal/images/master/Moving_Average.png)

#### Взвешенные скользящие средние (WMA) <a id ="17"></a>
WMA — это технический индикатор, который присваивает больший вес самым последним точкам данных и меньший вес точкам данных в далеком прошлом. WMA получается путем умножения каждого числа в наборе данных на заданный вес и суммирования полученных значений. Существует множество методов для присвоения весов. Популярным является экспоненциально взвешенное скользящее среднее, где веса присваиваются всем предыдущим значениям с коэффициентом затухания.

#### Центрированные скользящие средние (CMS) <a id ="18"></a>
В центрированном скользящем среднем значение скользящего среднего в момент времени t вычисляется путем центрирования окна вокруг времени t и усреднения по значениям w в пределах окна. Например, центральная скользящая средняя с окном 3 будет рассчитываться как
   ```
   CMA(t) = mean(t-1,t,t+1)
   ```
  
CMA очень полезен для визуализации данных временных рядов.
  
#### Движущиеся скользящие средние (TMA) <a id ="19"></a>
В скользящем среднем вместо усреднения по окну, которое сосредоточено вокруг интересующего периода времени, оно просто берет среднее значение последних значений w. Например, скользящая средняя с окном 3 будет рассчитываться как:
  ```
  TMA(t) = mean(t-2,t-1,t)
  ```
 
TMA полезны при прогнозировании.

## Корреляция <a id ="20"></a>
* Наиболее важным моментом в отношении значений во временном ряду является их зависимость от предыдущих значений.
* Мы можем рассчитать корреляцию для наблюдений временных рядов с предыдущими временными шагами, называемыми лагами (lags).
* Поскольку корреляция наблюдений временного ряда рассчитывается со значениями того же ряда в предыдущие моменты времени, это называется автокорреляцией или последовательной корреляцией.
* Чтобы лучше понять, давайте рассмотрим пример цен на рыбу. Мы будем использовать приведенные ниже обозначения для представления цен на рыбу.
    - P(t)= Сегодняшняя цена рыбы
    - P(t-1) = Цена рыбы в прошлом месяце
    - P(t-2) = Цена на рыбу в позапрошлом месяце
* Временные ряды цен на рыбу можно представить как P(t-n),..... P(t-3), P(t-2),P(t-1), P(t)
* Таким образом, если у нас есть цены на рыбу за последние несколько месяцев, нам будет легко спрогнозировать цену на рыбу на сегоднящгий день (здесь мы игнорируем все другие внешние факторы, которые могут повлиять на цены на рыбу).

Все прошлые и будущие точки данных связаны во временном ряду, и функции ACF и PACF помогают нам определить корреляцию в нем.

### Функция автокорреляции (ACF) <a id ="21"></a>
* ACF сообщает вам, насколько точки коррелируют друг с другом, исходя из того, сколько временных шагов они разделяют.
* Теперь, чтобы лучше понять, давайте рассмотрим приведенный выше пример цен на рыбу. Попробуем найти зависимость между ценой на рыбу в текущем месяце P(t) и двухмесячной давности P(t-2). Важно отметить, что цена на рыбу двухмесячной давности может напрямую влиять на сегодняшнюю цену на рыбу или косвенно влиять на цену на рыбу по цене прошлых месяцев P(t-1).
* Таким образом, ACF учитывает как прямое, так и косвенное влияние между точками при определении корреляции.

### Функция частичной автокорреляции (PACF) <a id ="22"></a>
* В отличие от ACF, PACF учитывает только прямое влияние между точками при определении корреляции
* В случае приведенного выше примера цены на рыбу PACF определит корреляцию между ценой на рыбу в текущем месяце P(t) и два месяца назад P(t-2), учитывая только P(t) и P(t-2) и игнорируя P(t-1).


# Прогнозирование временных рядов <a id ="23"></a>
Прогнозирование относится к прогнозам на будущее, основанным на анализе данных временных рядов. Ниже приведены шаги, выполняемые во время прогнозирования временных рядов.

* Шаг 1: Понимание характеристик временных рядов, таких как тренд, сезонность и т.д.
* Шаг 2: Проведите анализ и определите лучший метод, чтобы сделать временные ряды стационарными.
* Шаг 3: Запишите шаги преобразования, выполненные для того, чтобы сделать временной ряд стационарным, и убедитесь, что обратное преобразование данных возможно, чтобы вернуть исходную шкалу.
* Шаг 4: На основе анализа данных выберите подходящую модель для прогнозирования временных рядов.
* Шаг 5: Мы можем оценить производительность модели, применяя простые показатели, такие как остаточная сумма квадратов (RSS). Обязательно используйте все данные для прогнозирования.
* Шаг 6: Теперь у нас будет массив прогнозированных данных в преобразованной шкале. Нам просто нужно применить обратное преобразование, чтобы получить значения прогноза в исходной шкале.
* Шаг 7: В конце мы можем сделать прогноз на будущее и получить прогнозируемые значения в исходной шкале.

## Модели, используемые для прогнозирования временных рядов <a id ="24"></a>
* Авторегрессия (AR)
* Скользящее среднее (МА)
* Авторегрессионная скользящая средняя (ARMA)
* Авторегрессионное интегрированное скользящее среднее (ARIMA)
* Сезонная авторегрессионная интегрированная скользящая средняя (SARIMA)
* Сезонная авторегрессионная интегрированная скользящая средняя с экзогенными регрессорами (SARIMAX)
* Векторная авторегрессия (VAR)
* Векторная скользящая средняя авторегрессии (VARMA)
* Скользящая средняя векторной авторегрессии с экзогенными регрессорами (VARMAX)
* Простое экспоненциальное сглаживание (SES)
* Экспоненциальное сглаживание Холта Винтера (HWES)

В следующей части этой статьи мы собираемся анализировать и прогнозировать данные временных рядов авиапассажиров с использованием модели ARIMA. Краткое введение в модель ARIMA приведено ниже.

## ARIMA <a id ="25"></a>
* ARIMA означает авторегрессивные интегрированные скользящие средние. На самом деле это комбинация моделей AR и MA.
* ARIMA имеет три параметра «p» для порядка части авторегрессии (AR), «q» для порядка части скользящего среднего (MA) и «d» для порядка интегрированной части.

### Модель авторегрессии (AR): <a id ="26"></a>
* Как видно из названия, это регрессия переменных против самой себя. В этой модели линейная комбинация прошлых значений используется для прогнозирования будущих значений.
* Чтобы выяснить порядок модели AR, мы будем использовать функцию PACF.

### Интегрирование(I): <a id ="27"></a>
* Использует дифференцирование наблюдений (вычитание наблюдения из наблюдения на предыдущем временном шаге), чтобы сделать временной ряд стационарным. Дифференцирование включает вычитание текущих значений ряда с его предыдущими значениями d число раз.
* Значение d = 1 означает разницу первого порядка.

### Модель скользящей средней (MA): <a id ="28"></a>
* Вместо использования прошлых значений переменной прогноза в регрессии модель скользящего среднего использует линейную комбинацию прошлых ошибок прогноза.
* Чтобы выяснить порядок модели MA, мы будем использовать функцию ACF.
# Пример Python <a id ="29"></a>
У нас есть месячные данные временных рядов авиапассажиров с 1 января 1949 г. по 1 декабря 1960 г. Каждая строка содержит количество авиапассажиров за месяц этого конкретного года. Цель состоит в том, чтобы построить модель для прогнозирования пассажиропотока на будущие месяцы.
## Импорт библиотеки <a id ="30"></a>
* pandas: используется для обработки и анализа данных.
* numpy : Numpy — это основная библиотека для научных вычислений в Python. Используется для работы с массивами и матрицами.
* matplotlib: это библиотека для построения графиков, и мы собираемся использовать ее для визуализации данных.
* seaborn: это библиотека визуализации данных Python, основанная на matplotlib. Он предоставляет высокоуровневый интерфейс для рисования привлекательных и информативных статистических графиков.
* statsmodels: использование классов и функций модуля statsmodels для анализа и прогнозирования временных рядов.
    * adfuller: дополненный Дики-Фуллер
    * ACF: функция автоматической корреляции
    * PACF: функция частичной автокорреляции
    * ARIMA: авторегрессионная интегрированная модель скользящего среднего ARIMA(p,d,q)
    * sm.tsa.seasonal.seasonal_decompose: Для декомпозиции временных рядов
* rcParams: Чтобы изменить свойства matplotlib, такие как размер фигуры
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.stattools import adfuller,acf, pacf
from statsmodels.tsa.arima_model import ARIMA
import statsmodels.api as sm
from pylab import rcParams
# Set plot size 
rcParams['figure.figsize'] = 10, 6
df = pd.read_csv('https://raw.githubusercontent.com/satishgunjal/datasets/master/Time_Series_AirPassengers.csv')
print('Shape of the data= ', df.shape)
print('Column datatypes= \n',df.dtypes)
df
## Понимание данных <a id ="31"></a>
* Фрейм данных 'df' содержит данные временного ряда. Есть две колонки «Month» и «Passengers». Столбец «Month» содержит значение месяца в этом году, а столбец «Passengers» содержит количество авиапассажиров за этот конкретный месяц.
* Как вы могли заметить, тип данных столбца «Month» — «Object», поэтому мы собираемся преобразовать его в «datetime».
* Чтобы упростить построение графика, мы установили индекс фрейма данных pandas 'df' в столбец «Month», чтобы он действовал как ось X, а столбец «Passengers» — как ось Y.
df['Month'] = pd.to_datetime(df.Month)
df = df.set_index(df.Month)
df.drop('Month', axis = 1, inplace = True)
print('Column datatypes= \n',df.dtypes)
df
## Характеристики временных рядов <a id ="32"></a>

### Тренд
plt.figure(figsize= (10,6))
plt.plot(df)
plt.xlabel('Years')
plt.ylabel('No of Air Passengers')
plt.title('Trend of the Time Series')
Как видно из приведенного выше графика, наблюдается тенденция к увеличению количества пассажиров за каждый год.

### Дисперсия
На приведенном выше графике вы можете ясно видеть, что вариация также увеличивается с уровнем ряда. В следующих частях этого упражнения вы увидите, как мы обращаемся с дисперсией, чтобы повысить стационарность ряда.

### Сезонность
Мы также можем видеть, как график движется вверх и вниз через равные промежутки времени, что является признаком сезонности. Давайте построим график за несколько месяцев, чтобы визуализировать сезонность.
# To plot the seasonality we are going to create a temp dataframe and add columns for Month and Year values
df_temp = df.copy()
df_temp['Year'] = pd.DatetimeIndex(df_temp.index).year
df_temp['Month'] = pd.DatetimeIndex(df_temp.index).month
# Stacked line plot
plt.figure(figsize=(10,10))
plt.title('Seasonality of the Time Series')
sns.pointplot(x='Month',y='Passengers',hue='Year',data=df_temp)
Из приведенного выше графика мы можем сказать, что каждый год в июле мы наблюдаем максимальное количество пассажиров и аналогично минимальное количество пассажиров в ноябре.

### Декомпозиция временного ряда
Давайте теперь воспользуемся методом декомпозиции, чтобы разбить данные временных рядов на несколько компонентов, таких как тренд и сезонность, для визуализации характеристик временных рядов.

Здесь мы собираемся использовать «аддитивную» модель, потому что она быстро разрабатывается, быстро обучается и предоставляет интерпретируемые шаблоны.
decomposition = sm.tsa.seasonal_decompose(df, model='additive') 
fig = decomposition.plot()
## Анализ временных рядов <a id ="33"></a>
Таким образом, наш временной ряд имеет характеристики дисперсии, тренда и сезонности. Во время нашего анализа мы собираемся попробовать несколько методов, чтобы сделать временные ряды стационарными, и записать оценки стационарности для каждого метода. Наконец, мы выберем метод, который легко выполняет обратное преобразование и дает наилучший показатель стационарности.

### Проверка на стационарность
Мы собираемся использовать скользящую статистику и тест Дики-Фуллера, чтобы проверить стационарность временного ряда.
def stationarity_test(timeseries):
    # Get rolling statistics for window = 12 i.e. yearly statistics
    rolling_mean = timeseries.rolling(window = 12).mean()
    rolling_std = timeseries.rolling(window = 12).std()
    
    # Plot rolling statistic
    plt.figure(figsize= (10,6))
    plt.xlabel('Years')
    plt.ylabel('No of Air Passengers')    
    plt.title('Stationary Test: Rolling Mean and Standard Deviation')
    plt.plot(timeseries, color= 'blue', label= 'Original')
    plt.plot(rolling_mean, color= 'green', label= 'Rolling Mean')
    plt.plot(rolling_std, color= 'red', label= 'Rolling Std')   
    plt.legend()
    plt.show()
    
    # Dickey-Fuller test
    print('Results of Dickey-Fuller Test')
    df_test = adfuller(timeseries)
    df_output = pd.Series(df_test[0:4], index = ['Test Statistic', 'p-value', '#Lags Used', 'Number of Observations Used'])
    for key, value in df_test[4].items():
        df_output['Critical Value (%s)' %key] = value
    print(df_output)
# Lets test the stationarity score with original series data
stationarity_test(df)
Хотя из визуального наблюдения видно, что это не стационарный ряд, но все же давайте посмотрим на скользящую статистику и результаты теста Дики-Фуллера.

* Скользящая статистика: стандартное отклонение имеет очень маленькие вариации, но среднее значение постоянно увеличивается.
* Тест Дики-Фуллера: статистика теста намного больше, чем критические значения.

### Преобразование нестационарных данных в стационарные данные
Давайте сначала используем технику дифференциации, чтобы получить стационарность.

#### Дифференциация
Чтобы преобразовать ряд с помощью «дифференциации», мы будем использовать метод `diff()` из pandas. Преимущество использования функции Pandas, в дополнение к тому, что требуется меньше кода, заключается в том, что она поддерживает информацию о дате и времени для разностных рядов.
df_diff = df.diff(periods = 1) # First order differencing
plt.xlabel('Years')
plt.ylabel('No of Air Passengers')    
plt.title('Convert Non Stationary Data to Stationary Data using Differencing ')
plt.plot(df_diff)
Таким образом, из приведенного выше графика видно, что метод дифференцирования удалил тренд из временного ряда, но дисперсия все еще существует. Теперь давайте запустим `stationarity_test()`, чтобы проверить эффективность метода «дифференцирования».
df_diff.dropna(inplace = True)# Data transformation may add na values
stationarity_test(df_diff)
Скользящие значения, кажется, немного различаются, и мы можем видеть небольшую тенденцию к увеличению стандартного отклонения. Кроме того, тестовая статистика меньше критического значения 10%, но, поскольку значение p больше 0,05, это не стационарный ряд.

Обратите внимание, что дисперсия в ряду также влияет на приведенные выше результаты, которые можно удалить с помощью метода преобразования.

Давайте также проверим с помощью техники трансформации


#### Трансформация


Поскольку дисперсия пропорциональна уровням, мы собираемся использовать логарифмическое преобразование.
df_log = np.log(df)

plt.subplot(211)
plt.plot(df, label= 'Time Series with Variance')
plt.legend()
plt.subplot(212)
plt.plot(df_log, label='Time Series without Variance (Log Transformation)')
plt.legend()  
plt.show()
Поскольку логарифмическое преобразование удалило дисперсию из ряда, давайте использовать эти преобразованные данные в дальнейшем.
Обратите внимание, что, поскольку мы используем логарифмическое преобразование, мы можем использовать экспоненту ряда, чтобы вернуть исходный масштаб.
```
     df = exp(df_log)
```

Давайте еще раз перепроверим оценки метода разности с данными, преобразованными в log.
df_log_diff = df_log.diff(periods = 1) # First order differencing

df_log_diff.dropna(inplace = True)# Data transformation may add na values
stationarity_test(df_log_diff)
Скользящее среднее значение и стандартное отклонение теперь в норме. Статистика теста меньше 10% критических значений, но поскольку значение p больше 0,05, это не стационарный ряд.

Давайте также проверим технику скользящей средней…

#### Скользящее среднее

Поскольку у нас есть данные временного ряда с 1 января 1949 года по 1 декабря 1960 года, мы определим годовое окно для скользящей средней. Размер окна = 12. Обратите внимание, что мы собираемся использовать Log преобразованные данных.
df_log_moving_avg = df_log.rolling(window = 12).mean()
plt.xlabel('Years')
plt.ylabel('No of Air Passengers')    
plt.title('Convert Non Stationary Data to Stationary Data using Moving Average')
plt.plot(df_log, color= 'blue', label='Orignal')
plt.plot(df_log_moving_avg, color= 'red', label='Moving Average')
plt.legend()
Как вы можете видеть на графике выше, данные более гладкие без какой-либо дисперсии. Если мы используем метод разности с логарифмически преобразованными данными и средними данными, мы должны получить лучшие оценки стационарности.
df_log_moving_avg_diff = df_log - df_log_moving_avg
df_log_moving_avg_diff.dropna(inplace = True)
stationarity_test(df_log_moving_avg_diff)
Как и ожидалось, теперь мы можем увидеть некоторые реальные улучшения. p-значение меньше 0,05, что означает, что наш ряд является стационарным, но мы можем сказать об этом только с 95% уверенностью, поскольку критическое значение тестовой статистики составляет менее 5%.

Чтобы повысить стационарность ряда, попробуем использовать метод «взвешенного скользящего среднего».

#### Взвешенное скользящее среднее (WMA)

Здесь мы собираемся использовать экспоненциально взвешенную скользящую среднюю с параметром «halflife = 12». Этот параметр определяет величину экспоненциального затухания. Здесь это всего лишь предположение, и оно будет во многом зависеть от сферы бизнеса.
df_log_weighted_avg = df_log.ewm(halflife = 12).mean()
plt.plot(df_log)
plt.plot(df_log_weighted_avg, color = 'red')
Обратите внимание, что WMA более точно отслеживает значения количества пассажиров, чем соответствующее простое скользящее среднее, что также дает более точное направление тренда. Теперь давайте проверим влияние этого на показатели стационарности!
df_log_weighted_avg_diff = df_log - df_log_weighted_avg
stationarity_test(df_log_weighted_avg_diff)
Статистика теста меньше критического значения 1%, что лучше, чем в предыдущем случае. Обратите внимание, что в этом случае не будет пропущенных значений, так как всем значениям от начала присваиваются веса. Так что это будет работать даже без предыдущих значений.

Есть еще один способ получить лучшую стационарность, используя остаточные данные от декомпозиции временных рядов.

#### Декомпозиция временного ряда

Теперь давайте воспользуемся методом декомпозиции для разложения данных временного ряда, преобразованных в log, чтобы мы могли проверить стационарность, используя остаточные данные.
decomposition = sm.tsa.seasonal_decompose(df_log,period =12)
fig = decomposition.plot()
Здесь мы видим, что тренд и сезонность отделены от логарифмически преобразованных данных, и теперь мы можем проверить стационарность остатков.
df_log_residual = decomposition.resid
df_log_residual.dropna(inplace = True)
stationarity_test(df_log_residual)
Статистика теста Дики-Фуллера значительно ниже критического значения 1%, а значение p почти равно 0. Таким образом, этот временной ряд очень близок к стационарному. На этом мы завершаем анализ временных рядов и преобразование данных для получения стационарных рядов. Теперь мы можем приступить к моделированию для прогноза.

## Прогнозирование <a id ="34"></a>
* Хотя использование остаточных значений дает нам очень хорошие результаты, в этом случае относительно сложно добавить шум и сезонность обратно в предсказанные остатки.
* Итак, мы собираемся создать модель временного ряда (df_log_diff), где мы использовали log-реобразование и технику дифференцирования. Это одна из самых популярных и удобных для начинающих техник. Согласно нашему анализу временных рядов, «df_log_diff» не является совершенно стационарным рядом, поэтому мы собираемся использовать статистические модели, такие как ARIMA, для прогнозирования данных.
* Помните, что модель ARIMA использует три параметра: «p» для порядка части авторегрессии (AR), «q» для порядка части скользящего среднего (MA) и «d» для порядка интегрированной части. Мы собираемся использовать d = 1, но чтобы найти значение для p и q, давайте построим ACF и PACF.
* Обратите внимание, что, поскольку мы используем d = 1, для данной серии будет выполняться дифференцирование первого порядка. Поскольку первое значение временного ряда не имеет значения для вычитания из результирующего ряда, будет на одно значение меньше исходного ряда.

### Графики ACF и PACF
* Чтобы выяснить порядок модели AR (p), мы будем использовать функцию PACF. p = значение запаздывания, при котором диаграмма PACF впервые пересекает верхний доверительный интервал.
* Чтобы выяснить порядок модели MA (q), мы будем использовать функцию ACF. q = значение запаздывания, при котором график ACF впервые пересекает верхний доверительный интервал.
lag_acf = acf(df_log_diff, nlags=20)
lag_pacf = pacf(df_log_diff, nlags=20, method='ols')

# Plot ACF: 
plt.subplot(121) 
plt.plot(lag_acf)
plt.axhline(y=0,linestyle='--',color='gray')
# Draw 95% confidence interval line
plt.axhline(y=-1.96/np.sqrt(len(df_log_diff)),linestyle='--',color='red')
plt.axhline(y=1.96/np.sqrt(len(df_log_diff)),linestyle='--',color='red')
plt.xlabel('Lags')
plt.title('Autocorrelation Function')

#Plot PACF:
plt.subplot(122)
plt.plot(lag_pacf)
plt.axhline(y=0,linestyle='--',color='gray')
# Draw 95% confidence interval line
plt.axhline(y=-1.96/np.sqrt(len(df_log_diff)),linestyle='--',color='red')
plt.axhline(y=1.96/np.sqrt(len(df_log_diff)),linestyle='--',color='red')
plt.xlabel('Lags')
plt.title('Partial Autocorrelation Function')
plt.tight_layout()
Из приведенного выше графика видно, что p=2 и q=2. Теперь у нас есть значения параметров ARIMA, давайте создадим 3 разные модели ARIMA, учитывающие как индивидуальные, так и комбинированные эффекты. Мы также выведим метрику RSS (Residual Sum of Square) для каждого случая. Обратите внимание, что здесь RSS для значений остатков, а не фактических рядов.

### Модель дополненной реальности
Поскольку «q» является параметром модели MA, мы сохраним его значение равным «0».
# freq = 'MS' > The frequency of the time-series MS = calendar month begin
# The (p,d,q) order of the model for the number of AR parameters, differences, and MA parameters to use
model = ARIMA(df_log, order=(2, 1, 0), freq = 'MS')  
results_AR = model.fit(disp= -1)# If disp < 0 convergence information will not be printed
plt.plot(df_log_diff)
plt.plot(results_AR.fittedvalues, color='red')
plt.title('AR Model, RSS: %.4f'% sum((results_AR.fittedvalues - df_log_diff['Passengers'])**2))
### Модель MA
Поскольку «p» является параметром модели AR, мы сохраним его значение равным «0».
model = ARIMA(df_log, order=(0, 1, 2), freq = 'MS')  
results_MA = model.fit(disp=-1)  
plt.plot(df_log_diff)
plt.plot(results_MA.fittedvalues, color='red')
plt.title('MA Model, RSS: %.4f'% sum((results_MA.fittedvalues-df_log_diff['Passengers'])**2))
### Комбинированная модель
model = ARIMA(df_log, order=(2, 1, 2), freq = 'MS')  
results_ARIMA = model.fit(disp=-1)  
plt.plot(df_log_diff)
plt.plot(results_ARIMA.fittedvalues, color='red')
plt.title('Combined Model, RSS: %.4f'% sum((results_ARIMA.fittedvalues-df_log_diff['Passengers'])**2))
Здесь мы видим, что модели AR и MA имеют почти одинаковую оценку RSS, но в совокупности они значительно лучше. Итак, мы продолжим работу с комбинированной моделью ARIMA и будем использовать ее для прогнозов.

### Прогнозирование и обратное преобразование
* Мы создадим отдельную серию прогнозируемых значений, используя модель ARIMA.
* Обратное преобразование предсказанных значений, чтобы вернуть исходный масштаб
* Сравните прогнозируемые значения с исходными значениями и постройте их графики
# Create a separate series of predicted values
predictions_diff = pd.Series(results_ARIMA.fittedvalues, copy=True)

print('Total no of predictions: ', len(predictions_diff))
predictions_diff.head()
Поскольку мы используем первый порядок разности (d = 1), прогноз для первого значения (1949-02-01) исходного ряда недоступен. Чтобы удалить «разностное преобразование» из значений прогноза, мы последовательно добавим эти различия к базовому числу. Простой способ сделать это — сначала определить кумулятивную сумму по индексу, а затем добавить ее к базовому числу. Мы собираемся использовать для этого функцию pandas `cumsum()`.
predictions_diff_cumsum = predictions_diff.cumsum()
predictions_diff_cumsum.head()
Приведенные выше значения, добавленные к базовому числу, полностью удалят разностное преобразование. Для этого давайте создадим ряд со всеми значениями в качестве базового числа и добавим к нему «predictions_diff_cumsum».
predictions_log = pd.Series(df_log['Passengers'].iloc[0], index=df_log.index) # Series of base number
predictions_log = predictions_log.add(predictions_diff_cumsum,fill_value=0)
predictions_log.head()
Итак, на данный момент мы удалили разностное преобразование, теперь давайте удалим логарифмическое преобразование, чтобы вернуть исходное масштабирование.
predictions = np.exp(predictions_log)
plt.plot(df)
plt.plot(predictions)
df_predictions =pd.DataFrame(predictions, columns=['Predicted Values'])
pd.concat([df,df_predictions],axis =1).T
### Прогнозирование будущего
* У нас есть данные с 1 января 1949 г. по 1 декабря 1960 г. Данные за 12 лет с наблюдением за количеством пассажиров за каждый месяц, т.е. всего 144 наблюдения.
* Если мы хотим составить прогноз на следующие 5 лет или 60 месяцев, то «конечный» счет будет > 144 + 60 = 204.
* Мы собираемся использовать для этого метод statsmodels `plot_predict()`
results_ARIMA.plot_predict(start = 1, end= 204) 
# Forecasted values in original scale will be
forecast_values_log_scale = results_ARIMA.forecast(steps = 60)
forecast_values_original_scale = np.exp(forecast_values_log_scale[0])

forecast_date_range= pd.date_range("1961-01-01", "1965-12-01", freq="MS")

df_forecast =pd.DataFrame(forecast_values_original_scale, columns=['Forecast'])
df_forecast['Month'] = forecast_date_range

df_forecast[['Month', 'Forecast']]
Справочный материал. 
* https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/
* https://www.kaggle.com/freespirit08/time-series-for-beginners-with-arima/notebook
* https://maelfabien.github.io/statistics/TimeSeries3/#
* https://www.geeksforgeeks.org/python-arima-model-for-time-series-forecasting/
* https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/
* https://www.kaggle.com/chirag19/time-series-analysis-with-python-beginner/notebook
* https://www.kaggle.com/freespirit08/time-series-for-beginners-with-arima/notebook
* https://www.youtube.com/watch?v=gj4L2isnOf8&t=1167s
* https://www.digitalocean.com/community/tutorials/a-guide-to-time-series-visualization-with-python-3
* https://towardsdatascience.com/analyzing-time-series-data-in-pandas-be3887fdd621
* https://machinelearningmastery.com/power-transform-time-series-forecast-data-python/
* https://www.geeksforgeeks.org/python-arima-model-for-time-series-forecasting/
